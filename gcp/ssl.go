package gcp

import (
	"bytes"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"time"

	"github.com/lestrrat/go-pdebug"
	"google.golang.org/api/compute/v1"
  k8sapi "k8s.io/kubernetes/pkg/api"
  k8sclient "k8s.io/kubernetes/pkg/client/unversioned"
)

func NewSecretUpload(c *k8sclient.Client, namespace string) *SecretUpload {
	return &SecretUpload{
		Client: c,
		Namespace: namespace,
	}
}

func (su *SecretUpload) Upload(name string, certs []*x509.Certificate, certkey *rsa.PrivateKey) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("SecretUpload.Upload (%s)", name).BindError(&err)
		defer g.End()
	}

	secret := k8sapi.Secret{
		Type: "Opaque",
		Data: map[string][]byte{
			"tls.crt": []byte{}, // FIXME
			"tls.key": []byte{}, // FIXME
		},
		ObjectMeta: k8sapi.ObjectMeta{
			Name: name,
		},
	}
	secretsvc := su.Client.Secrets("default")
	if _, err = secretsvc.Create(&secret); err != nil {
		return err
	}
	return nil
}

func NewLBUpload(s *compute.Service, projectID string) *LBUpload {
	return &LBUpload{
		Project: projectID,
		Service: s,
	}
}

func (cu *LBUpload) Upload(name string, certs []*x509.Certificate, certkey *rsa.PrivateKey) (err error) {
	if pdebug.Enabled {
		g := pdebug.Marker("LBUpload.Upload (%s)", name).BindError(&err)
		defer g.End()
	}

	certbuf := bytes.Buffer{}
	for _, cert := range certs {
		if err := pem.Encode(&certbuf, &pem.Block{Type: "CERTIFICATE", Bytes: cert.Raw}); err != nil {
			return err
		}
	}

	keybuf := bytes.Buffer{}
	if err := pem.Encode(&keybuf, &pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(certkey)}); err != nil {
		return err
	}

	sslcert := compute.SslCertificate{
		Certificate: certbuf.String(),
		Description: "Certificate generated by Let's Encrypt, uploaded by go-cloud-acmeagent",
		Name:        name,
		PrivateKey:  keybuf.String(),
	}
	oper, err := cu.Service.SslCertificates.Insert(cu.Project, &sslcert).Do()
	if err != nil {
		return err
	}

	// Poll until the operation is done
	timeout := time.After(5 * time.Minute)
	ticker := time.Tick(5 * time.Second)
	for {
		select {
		case <-timeout:
			return errors.New("timed out waiting for certificate upload")
		case <-ticker:
			oper, err = cu.Service.GlobalOperations.Get(cu.Project, oper.Name).Do()
			if err != nil {
				return err
			}
			switch oper.Status {
			case "DONE":
				if oper.Error != nil {
					buf := bytes.Buffer{}
					for i, e := range oper.Error.Errors {
						if i != 0 {
							buf.WriteByte('\n')
						}
						buf.WriteString(e.Message)
					}
					return errors.New(buf.String())
				}
				return nil
			default:
				if pdebug.Enabled {
					pdebug.Printf("Certificates are not ready. waiting...")
				}
				continue
			}
		}
	}

	return errors.New("failed to poll for operation status")
}
